import sqlglot

# Debugged with Chatgpt 5.2
def get_column_comments(conn, table, schema, column_data_dict):
    with conn.cursor() as cursor:
        # SQL generated with Chatgpt 5.2
        sql = """
            SELECT column_name, comments
            FROM all_col_comments
            WHERE owner = :owner
              AND table_name = :table_name
        """
        cursor.execute(sql, {"owner": schema, "table_name": table})
        rows = cursor.fetchall()

    comment_by_exact = {}
    comment_by_upper = {}
    for col_name, comment in rows:
        if col_name is None:
            continue
        comment_by_exact[col_name] = comment
        comment_by_upper[str(col_name).upper()] = comment


    for col in column_data_dict[table]["columns"]:
        col_name = col[0]
        if col_name is None:
            continue

        comment = comment_by_exact.get(col_name)
        if comment is None:
            comment = comment_by_upper.get(str(col_name).upper())

        col[6] = comment 

    return column_data_dict


def get_all_schemas(conn):
    oracle_schemas = ["ADMIN_ALL","APPQOSSYS","ANONYMOUS","AUDSYS", "CTXSYS", "DBSFWUSER", "DBSNMP","DGPDB_INT","DIP","DVF", "DVSYS","GGSYS","GSMCATUSER","GSMUSER","MDDATA","ORACLE_OCM","ORDPLUGINS","PDBADMIN","REMOTE_SCHEDULER_AGENT","SI_INFORMTN_SCHEMA","SYSBACKUP","SYSDG","SYSKM","SYSRAC","SYS$UMF","XS$NULL", "GSMADMIN_INTERNAL", "LBACSYS", "MDSYS", "OJVMSYS", "OLAPSYS","ORDDATA", "ORDSYS","OUTLN", "SYS", "SYSTEM", "WMSYS", "XDB"]
    with conn.cursor() as cursor:
        sql_schemata = "SELECT username FROM all_users ORDER BY username"
        schemata = []
        for r in cursor.execute(sql_schemata):
            if r[0] not in oracle_schemas:
                schemata.append(r[0])
    return schemata

def get_tables(conn, owner):
    with conn.cursor() as cursor:
        # SQL optimized with Chatgpt 5.2: Replacing the owner with a placholder - later implemented in other queries
        sql_tables = "SELECT table_name FROM all_tables WHERE owner = :t"
        tables = []
        for r in cursor.execute(sql_tables, {"t":owner}):
            tables.append(r[0])
    return tables

def create_data_dict(tables):
    column_data_dict = {}
    for table in tables:
        column_data_dict[table] = {"row_count" : int, "columns" : [], "constraints" : [], "indexes": []}
    return column_data_dict

def get_column_row_count(conn, column_data_dict, schema):
    tables = column_data_dict.keys()
    for table in tables:
        count_sql = f""" SELECT COUNT(*) FROM "{schema}"."{table}" """
        with conn.cursor() as cursor:
            
            cursor.execute(count_sql)
            row_count =  cursor.fetchone()[0]

        column_data_dict[table]["row_count"] = row_count
    return column_data_dict


# Debugged with Gemini 3
def   get_column_constraints(conn, column_data_dict, schema):
    tables = column_data_dict.keys()
    for table in tables:
        # SQL generated by Chat GPT 5.2
        column_constraint_sql = """ SELECT
                                        cons.owner,
                                        cons.table_name,
                                        cons.constraint_name,
                                        cons.constraint_type,
                                        cols.column_name,
                                        cols.position,
                                        cons.r_owner,
                                        cons.r_constraint_name,
                                        rcols.table_name AS r_table_name,
                                        rcols.column_name AS r_column_name,
                                        rcols.position AS r_position,
                                        cons.search_condition,
                                        cons.deferrable,
                                        cons.deferred,
                                        cons.status,
                                        cons.validated,
                                        cons.INDEX_NAME
                                    FROM all_constraints cons
                                    LEFT JOIN all_cons_columns cols
                                        ON cons.owner = cols.owner
                                        AND cons.constraint_name = cols.constraint_name
                                        AND cons.table_name = cols.table_name
                                    LEFT JOIN all_cons_columns rcols
                                        ON cons.r_owner = rcols.owner
                                        AND cons.r_constraint_name = rcols.constraint_name
                                        AND rcols.position = cols.position
                                    WHERE cons.owner = :s
                                    AND cons.table_name NOT LIKE 'BIN$%'
                                    AND cons.constraint_name NOT LIKE 'BIN$%'
                                    AND cons.table_name = :t
                                    ORDER BY
                                        cons.constraint_type,
                                        cons.constraint_name,
                                        cols.position
                                """
        with conn.cursor() as cursor:
            cursor.execute(column_constraint_sql, {"t":table, "s": schema})
            column_constraints = cursor.fetchall()
            #print(column_constraints)

            cleaned_constraint_list = []

            for constraint in column_constraints:
                search_condition = constraint[11]
                if search_condition != None:
                    search_condition = search_condition.upper().replace('"', '').strip()
                    if 'IS NOT NULL' not in search_condition:
                        cleaned_constraint_list.append(constraint)
                else:
                    cleaned_constraint_list.append(constraint)


            column_data_dict[table]["constraints"] = cleaned_constraint_list
    return column_data_dict

# Debugged with Chat GPT 5.2
def get_column_data(conn, column_data_dict, schema):
    tables = column_data_dict.keys()
    for table in tables:
        # SQL Generated by Chat GPT 5.2
        column_data_sql = """
            SELECT column_name,
                   data_type,
                   data_length,
                   data_precision,
                   data_scale,
                   nullable,
                   data_default,
                   identity_column
            FROM all_tab_columns
            WHERE table_name = :t
              AND owner = :s
            ORDER BY column_id
        """
        with conn.cursor() as cursor:
            
            cursor.execute(column_data_sql, {"t":table, "s": schema})
            column_data = cursor.fetchall()
        for column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, identity_column in column_data:
                column_data_dict[table]["columns"].append([column_name, data_type, data_length, data_precision, data_scale, nullable, None, data_default, identity_column])

        column_data_dict = get_column_comments(conn, table, schema, column_data_dict)

    return column_data_dict

def get_oracle_data(connection, tables, schema):
    column_data = {}
    for table in tables:
        cursor = connection.cursor()
        select_sql = f"""SELECT * FROM "{schema}"."{table}" """
        cursor.execute(select_sql)
        column_data_tuple = cursor.fetchall()
        column_data[table] = column_data_tuple 
    return(column_data)


def get_oracle_indexes(conn, column_data_dict, schema):
    tables = column_data_dict.keys()
    # SQL expanded and rewritten by Chatgpt 5.2 with initial SQL from: https://dataedo.com/kb/query/oracle/list-all-indexes-in-the-database [Accessed 08.02.2026]
    index_sql = """
        select ind.index_name,
               ind_col.column_name,
               ind_col.column_position,
               ind_col.descend,
               ind.index_type,
               ind.uniqueness,
               ind.table_owner as schema_name,
               ind.table_name as object_name,
               ind.table_type as object_type
        from sys.all_indexes ind
        join sys.all_ind_columns ind_col
          on ind.owner = ind_col.index_owner
         and ind.index_name = ind_col.index_name
        where ind.owner not in (
            'ANONYMOUS','CTXSYS','DBSNMP','EXFSYS','LBACSYS','MDSYS','MGMT_VIEW','OLAPSYS',
            'OWBSYS','ORDPLUGINS','ORDSYS','OUTLN','SI_INFORMTN_SCHEMA','SYS','SYSMAN',
            'SYSTEM','TSMSYS','WK_TEST','WKPROXY','WMSYS','XDB','APEX_040000',
            'APEX_PUBLIC_USER','DIP','WKSYS','FLOWS_30000','FLOWS_FILES','MDDATA',
            'ORACLE_OCM','XS$NULL','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','PUBLIC'
        )
          and ind.table_owner = :s
          and ind.table_name = :t
        order by ind.table_owner, ind.table_name, ind.index_name, ind_col.column_position
    """

    # Debugged with chat gpt 5.2
    for table in tables:
        constraint_index_names = {
            c[16] for c in column_data_dict[table]["constraints"] if c[16] is not None
        }

        with conn.cursor() as cursor:
            cursor.execute(index_sql, {"t": table, "s": schema})
            indexes = cursor.fetchall()

        for (index_name, column_name, column_position, descend,
             index_type, uniqueness, table_owner, table_name, table_type) in indexes:

            if index_name not in constraint_index_names:
                column_data_dict[table]["indexes"].append([
                    index_name, column_name, column_position, descend,
                    index_type, uniqueness, table_owner, table_name, table_type
                ])

    return column_data_dict


import re

# Mit Gemini 3 und Chatgpt 5.2 generiert
def transpile_view_syntax(sql_text: str) -> str:
    if not sql_text:
        return ""

    s = sql_text

    # 0) Kommentare entfernen (block + line) - schützt dich vor kaputten SELECTs
    s = re.sub(r"/\*.*?\*/", " ", s, flags=re.S)
    s = re.sub(r"--[^\n]*", " ", s)

    # 1) NVL -> COALESCE
    s = re.sub(r"\bNVL\s*\(", "COALESCE(", s, flags=re.I)

    # 2) SYSDATE -> CURRENT_TIMESTAMP (oder CURRENT_DATE, je nach Semantik)
    s = re.sub(r"\bSYSDATE\b", "CURRENT_TIMESTAMP", s, flags=re.I)

    # 3) DBMS_LOB.GETLENGTH(x) -> length(x)
    s = re.sub(r"\bDBMS_LOB\.GETLENGTH\s*\(", "length(", s, flags=re.I)

    # 4) DBMS_LOB.SUBSTR(expr, amount, offset) -> substring(expr from offset for amount)
    # Oracle: SUBSTR(expr, amount, offset)
    # PG: substring(expr from offset for amount)

    def repl_lob_substr(m: re.Match) -> str:
        expr = m.group(1).strip()
        amount = m.group(2).strip()
        offset = m.group(3).strip()
        return f"substring({expr} from {offset} for {amount})"

    # Sehr tolerant: expr = alles bis zum ersten Komma
    s = re.sub(
        r"(?i)\bDBMS_LOB\s*\.\s*SUBSTR\s*\(\s*([^,]+?)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)",
        repl_lob_substr,
        s
    )

    # Fallback: falls DBMS_LOB.<irgendwas> noch existiert -> Prefix entfernen,
    # damit PG nicht nach Schema "dbms_lob" sucht.
    s = re.sub(r"(?i)\bDBMS_LOB\s*\.\s*", "", s)

    # 5) RAWTOHEX(x) -> encode(x::bytea, 'hex')
    s = re.sub(
        r"\bRAWTOHEX\s*\(\s*([^)]+?)\s*\)",
        r"encode(\1::bytea, 'hex')",
        s,
        flags=re.I
    )

    # 6) DM_LONG_TO_CLOB(...) -> legacy_long (dein Spezialfall)
    s = re.sub(r"\bDM_LONG_TO_CLOB\s*\(\s*[^)]*\s*\)", "legacy_long", s, flags=re.I)

    # 7) TRUNC(date) -> date_trunc('day', date)::date (für day-bucketing)
    s = re.sub(
        r"\bTRUNC\s*\(\s*([^)]+?)\s*\)",
        r"date_trunc('day', \1)::date",
        s,
        flags=re.I
    )

    # 8) Oracle-ish DATE_TRUNC('DD', x) -> date_trunc('day', x)
    s = re.sub(r"date_trunc\(\s*'DD'\s*,", "date_trunc('day',", s, flags=re.I)


    # 10) Whitespace normalisieren (optional)
    s = re.sub(r"\s+", " ", s).strip()

    return s


def get_oracle_views(conn, schema):
    # SQL Generated by Chat GPT 5.2
    view_sql = """
            SELECT VIEW_NAME, TEXT, OWNER
            FROM ALL_VIEWS WHERE OWNER NOT IN ('SYS', 'AUDSYS', 'DBSNMP', 'GSMADMIN_INTERNAL', 'XDB', 'WMSYS', 'CTXSYS', 'ORDSYS', 'ORDDATA', 'OLAPSYS', 'MDSYS', 'LBACSYS', 'DVSYS', 'SYSTEM') AND OWNER = :s
                """

    with conn.cursor() as cursor:
        cursor.execute(view_sql, {"s": schema})
        views = cursor.fetchall()

    for view in views:
        view_name = view[0]
        view_list = list(view)

        transpiled_sqlglot_sql = sqlglot.transpile(view_list[1], read="oracle", write="postgres")[0]
        transpiled_sqlglot_sql = transpiled_sqlglot_sql.replace("\r\n", " ")
        transpiled_sql = transpile_view_syntax(transpiled_sqlglot_sql)

        view_list[1] = view_list[1].replace("\r\n", " ")
        # Edited by GitHub Copilot v1.0: Temporarily set search_path so that implicit table names are resolved in the correct schema
        build_view_creation_sql = f'SET search_path = "{schema}", public;\nCREATE OR REPLACE VIEW "{schema}"."{view_name}" AS {transpiled_sql}'
        # 
        
        with open("view.txt", "a") as output:
            output.write(f"{build_view_creation_sql};\n\n")

# Debugged with Gemini 3
def get_oracle_sequences(conn, schema):
    # SQL generated with Chat GPT 5.2
    sequence_extract_sql = """
        SELECT sequence_name,
                min_value,
                max_value,
                increment_by,
                cycle_flag,
                cache_size,
                order_flag,
                last_number
            FROM all_sequences
            WHERE sequence_owner = :s
            ORDER BY sequence_name
    """

    with conn.cursor() as cursor:
        cursor.execute(sequence_extract_sql, {"s": schema})
        sequences = cursor.fetchall()
    
    list_of_sequences = []
    for sequence in sequences:
        max_value = sequence[2]
        cache_size = sequence[5]

        if max_value > 9223372036854775807:
            max_value = 9223372036854775807
        
        list_of_sequences.append({"sequence_name" : sequence[0], "min_value":sequence[1], "max_value":max_value, "increment_by":sequence[3], "cycle_flag":sequence[4], "cache_size":sequence[5], "order_flag":sequence[6], "last_number":sequence[7]})

    return list_of_sequences

