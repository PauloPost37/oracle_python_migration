
import re

# CHAT gpt generuert
def get_pk_metadata(column_data_dict, table):
    pk_cols = []
    pk_deferrable = None
    pk_deferred = None
    pk_validated = None

    for c in column_data_dict[table]["constraints"]:
        if c[3] == "P":
            col_name = c[4]
            pos = c[5]
            pk_cols.append((pos, col_name))
            # deferrable / deferred / validated flags live on the PK constraint row
            pk_deferrable = pk_deferrable or c[12]
            pk_deferred = pk_deferred or c[13]
            pk_validated = pk_validated or c[15]

    pk_cols.sort(key=lambda x: x[0])
    return {
        "columns": [col for _, col in pk_cols],
        "deferrable": pk_deferrable,
        "deferred": pk_deferred,
        "validated": pk_validated,
    }

# Mit chatGPT debugged
def create_postgreSQL_DDL(un, tables, column_data_dict, data_mapping):
    schema_creation_sql = f'CREATE SCHEMA IF NOT EXISTS "{un}";\n'
    with open("output.txt", "a") as output:
        output.write(schema_creation_sql)
    for table in tables:
        column_lines = []
        comment_lines = []
        pk_meta = get_pk_metadata(column_data_dict, table)
        pk_cols = pk_meta["columns"]

        for column in column_data_dict[table]["columns"]:
            column_name = column[0]
            oracle_type = column[1]
            nullable = column[5]  # "N" means NOT NULL
            oracle_default = column[7]
            oracle_identity = column[8]
            correct_mapping = data_mapping.get(oracle_type, "text")

            not_null = " NOT NULL" if nullable == "N" else ""

            pg_default = None
            if oracle_default:
                default_clean = str(oracle_default).strip()
                default_upper = default_clean.upper()

                # Common Oracle defaults mapped to PG equivalents
                if default_upper == "SYSDATE" or default_upper == "SYSTIMESTAMP":
                    pg_default = "CURRENT_TIMESTAMP"
                elif default_upper == "CURRENT_DATE":
                    pg_default = "CURRENT_DATE"
                elif default_upper == "USER":
                    pg_default = "CURRENT_USER"
                elif "NEXTVAL" in default_upper:
                    # Convert sequence nextval to PG format: nextval('seq')
                    seq_match = re.search(r"([A-Za-z0-9_.$]+)\s*\.\s*NEXTVAL", default_upper)
                    seq_name = seq_match.group(1) if seq_match else default_clean.replace('"', '')
                    seq_name = seq_name.replace(".", "_")
                    pg_default = f"nextval('{seq_name}')"
                elif default_upper.startswith("TO_DATE(") or default_upper.startswith("TO_TIMESTAMP("):
                    pg_default = default_clean  # Postgres supports these functions
                else:
                    is_number = default_clean.replace(".", "", 1).lstrip("-").isdigit()
                    if default_clean.startswith(("'", '"')) or is_number:
                        pg_default = default_clean
                    else:
                        pg_default = "'" + default_clean.replace("'", "''") + "'"

            default = f" DEFAULT {pg_default}" if pg_default else ""

            identity_sql = ""
            if oracle_identity == "YES":
                identity_sql = " GENERATED BY DEFAULT AS IDENTITY"
                default = ""

            column_lines.append(f'  "{column_name}"    {correct_mapping}{identity_sql}{not_null}{default}')

            if column[6] is not None:
                comment_text = str(column[6]).replace("'", "''")
                comment_lines.append(
                    f'COMMENT ON COLUMN "{un}"."{table}"."{column_name}" IS \'{comment_text}\';'
                )

        if pk_cols:
            pk_line = '  PRIMARY KEY (' + ', '.join(f'"{c}"' for c in pk_cols) + ')'

            deferrable = pk_meta.get("deferrable")
            deferred = pk_meta.get("deferred")
            validated = pk_meta.get("validated")

            if deferrable and str(deferrable).upper() == "DEFERRABLE":
                pk_line += " DEFERRABLE"
                if deferred and str(deferred).upper() == "DEFERRED":
                    pk_line += " INITIALLY DEFERRED"
                else:
                    pk_line += " INITIALLY IMMEDIATE"
            else:
                pk_line += " NOT DEFERRABLE"

            if validated and str(validated).upper() == "NOT VALIDATED":
                pk_line += " NOT VALIDATED"

            column_lines.append(pk_line)

        create_table_sql = f'CREATE TABLE IF NOT EXISTS "{un}"."{table}" ( \n' + ",\n".join(column_lines) + "\n);\n\n"
        with open("output.txt", "a") as output:
            output.write(create_table_sql)
            if comment_lines:
                output.write("\n".join(comment_lines) + "\n")







def create_postgreSQL_Schema(connection, schema_ddl):
    cursor = connection.cursor()
    cursor.execute(f"{schema_ddl}")
    connection.commit()

"""
### BROKEN
def create_postgreSQL_table(connection, table_ddl):
    cursor = connection.cursor()
    print(table_ddl)
    cursor.execute(f"{table_ddl}")
    connection.commit()

def create_postgreSQL_comments(connection, comment_ddl):
    cursor = connection.cursor()
    cursor.execute(f"{comment_ddl}")
    connection.commit()
"""

def exec_pg_list(connection, stmts):
    cur = connection.cursor()
    for stmt in stmts:
        cur.execute(stmt)
    connection.commit()