
import re

# Generated with Chatgpt 5.2
def get_pk_metadata(column_data_dict, table):
    pk_cols = []
    pk_deferrable = None
    pk_deferred = None
    pk_validated = None

    for c in column_data_dict[table]["constraints"]:
        if c[3] == "P":
            col_name = c[4]
            pos = c[5]
            pk_cols.append((pos, col_name))
            # deferrable / deferred / validated flags live on the PK constraint row
            pk_deferrable = pk_deferrable or c[12]
            pk_deferred = pk_deferred or c[13]
            pk_validated = pk_validated or c[15]

    pk_cols.sort(key=lambda x: x[0])
    return {
        "columns": [col for _, col in pk_cols],
        "deferrable": pk_deferrable,
        "deferred": pk_deferred,
        "validated": pk_validated,
    }

# Partially generated with chatGPT 5.2 and debugged with Chatgpt 5.2
def create_postgreSQL_DDL(un, tables, column_data_dict, data_mapping):
    schema_creation_sql = f'CREATE SCHEMA IF NOT EXISTS "{un}";\n'
    with open("output.txt", "a") as output:
        output.write(schema_creation_sql)

    with open("output_oneline.txt", "a") as output:
        output.write(schema_creation_sql)
    for table in tables:
        # Added by GitHub Copilot v1.0: Drop table to prevent unique constraint errors on re-run
        drop_table_sql = f'DROP TABLE IF EXISTS "{un}"."{table.lower()}" CASCADE;\n'
        with open("output.txt", "a") as output:
            output.write(drop_table_sql)

        column_lines = []
        comment_lines = []
        pk_meta = get_pk_metadata(column_data_dict, table)
        pk_cols = pk_meta["columns"]

        for column in column_data_dict[table]["columns"]:
            column_name = column[0]
            oracle_type = column[1]
            nullable = column[5] 
            oracle_default = column[7]
            oracle_identity = column[8]
            correct_mapping = data_mapping.get(oracle_type, "text")

            not_null = " NOT NULL" if nullable == "N" else ""

            pg_default = None
            if oracle_default == 'NULL':
                default = ""
            elif oracle_default:
                default_clean = str(oracle_default).strip()
                default_upper = default_clean.upper()

                # Common Oracle defaults mapped to PG equivalents
                if default_upper == "SYSDATE" or default_upper == "SYSTIMESTAMP":
                    pg_default = "CURRENT_TIMESTAMP"
                elif default_upper == "CURRENT_DATE":
                    pg_default = "CURRENT_DATE"
                elif default_upper == "USER":
                    pg_default = "CURRENT_USER"
                elif "NEXTVAL" in default_upper:
                    # Convert sequence nextval to PG format: nextval('seq')
                    seq_match = re.search(r"([A-Za-z0-9_.$]+)\s*\.\s*NEXTVAL", default_upper)
                    seq_name = seq_match.group(1) if seq_match else default_clean.replace('"', '')
                    seq_name = seq_name.replace(".", "_")
                    pg_default = f"nextval('{seq_name.lower()}')"
                elif default_upper.startswith("TO_DATE(") or default_upper.startswith("TO_TIMESTAMP("):
                    pg_default = default_clean  # Postgres supports these functions
                else:
                    is_number = default_clean.replace(".", "", 1).lstrip("-").isdigit()
                    if default_clean.startswith(("'", '"')) or is_number:
                        pg_default = default_clean
                    else:
                        pg_default = "'" + default_clean.replace("'", "''") + "'"
            
            default = f" DEFAULT {pg_default}" if pg_default else ""

            identity_sql = ""
            if oracle_identity == "YES":
                identity_sql = " GENERATED BY DEFAULT AS IDENTITY"
                default = ""
                # Fix: Postgres identity columns must be INT/BIGINT. 'numeric' will crash.
                if correct_mapping in ["numeric", "decimal"]:
                    correct_mapping = "bigint"

            column_lines.append(f'  "{column_name.lower()}"    {correct_mapping}{identity_sql}{not_null}{default}')

            if column[6] is not None:
                comment_text = str(column[6]).replace("'", "''")
                comment_lines.append(
                    f'COMMENT ON COLUMN "{un}"."{table.lower()}"."{column_name.lower()}" IS \'{comment_text}\';'
                )

        if pk_cols:
            pk_line = '  PRIMARY KEY (' + ', '.join(f'"{c.lower()}"' for c in pk_cols) + ')'

            deferrable = pk_meta.get("deferrable")
            deferred = pk_meta.get("deferred")
            validated = pk_meta.get("validated")

            if deferrable and str(deferrable).upper() == "DEFERRABLE":
                pk_line += " DEFERRABLE"
                if deferred and str(deferred).upper() == "DEFERRED":
                    pk_line += " INITIALLY DEFERRED"
                else:
                    pk_line += " INITIALLY IMMEDIATE"
            else:
                pk_line += " NOT DEFERRABLE"

            if validated and str(validated).upper() == "NOT VALIDATED":
                pk_line += " NOT VALIDATED"

            column_lines.append(pk_line)

        create_table_sql = f'CREATE TABLE IF NOT EXISTS "{un}"."{table.lower()}" ( \n' + ",\n".join(column_lines) + "\n);\n\n"
        create_table_one_line_sql = f'CREATE TABLE IF NOT EXISTS "{un}"."{table.lower()}" (' + ",".join(column_lines) + ");\n\n"
        with open("output.txt", "a") as output:
            output.write(create_table_sql)
            if comment_lines:
                output.write("\n".join(comment_lines) + "\n")
        with open("output_oneline.txt", "a") as output:
            output.write(create_table_one_line_sql)
            if comment_lines:
                output.write("\n".join(comment_lines) + "\n")


def create_postgreSQL_Sequences(sequences, schema):
    # Sequence structure : {"sequence_name" : sequence[0], "min_value":sequence[1], "max_value":sequence[2], "increment_by":sequence[3], "cycle_flag":sequence[4], "cache_size":sequence[5], "order_flag":sequence[6], "last_number":sequence[7]}
    for sequence in sequences:

        CYCLE = "NO"
        if sequence["cycle_flag"] == "Y":
            CYCLE = ""

        Cache = ""
        if sequence["cache_size"] != 0:
            Cache = f'Cache {sequence["cache_size"]}'


        sequence_sql = f"""CREATE SEQUENCE IF NOT EXISTS "{schema}".{sequence['sequence_name'].lower()} INCREMENT BY {sequence['increment_by']} MINVALUE {sequence['min_value']} MAXVALUE {sequence['max_value']} {CYCLE} CYCLE START {sequence['last_number']} {Cache}"""
   
        with open("sequences.txt", "a") as output:
            output.write(f"{sequence_sql}; \n")

